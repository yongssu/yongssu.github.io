<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="servlet,spring,async,">










<meta name="description" content="本文主要介绍spring异步请求模型实践使用，spirng中@Async的使用以及java8中提供CompletableFuture常用的API组合，利用这些现成的工具，可以解决平时项目中遇到的并发任务问题。 servlet3.0 async io有时候，Filter 及/或 Servlet 在生成响应之前必须等待一些资源或事件以便完成请求处理。比如，Servlet 在进行生成一个响应之前可能等">
<meta name="keywords" content="servlet,spring,async">
<meta property="og:type" content="article">
<meta property="og:title" content="spring async与CompletableFuture异步模型实践指南">
<meta property="og:url" content="https://www.suys.top/2018/12/23/2-spring async与CompletableFuture异步模型实践指南/index.html">
<meta property="og:site_name" content="YONGSSU的技术站点">
<meta property="og:description" content="本文主要介绍spring异步请求模型实践使用，spirng中@Async的使用以及java8中提供CompletableFuture常用的API组合，利用这些现成的工具，可以解决平时项目中遇到的并发任务问题。 servlet3.0 async io有时候，Filter 及/或 Servlet 在生成响应之前必须等待一些资源或事件以便完成请求处理。比如，Servlet 在进行生成一个响应之前可能等">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006ZwoZEly1fyotwiwqtkj30dw08vaau.jpg">
<meta property="og:updated_time" content="2018-12-30T08:00:44.808Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring async与CompletableFuture异步模型实践指南">
<meta name="twitter:description" content="本文主要介绍spring异步请求模型实践使用，spirng中@Async的使用以及java8中提供CompletableFuture常用的API组合，利用这些现成的工具，可以解决平时项目中遇到的并发任务问题。 servlet3.0 async io有时候，Filter 及/或 Servlet 在生成响应之前必须等待一些资源或事件以便完成请求处理。比如，Servlet 在进行生成一个响应之前可能等">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/006ZwoZEly1fyotwiwqtkj30dw08vaau.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.suys.top/2018/12/23/2-spring async与CompletableFuture异步模型实践指南/">





  <title>spring async与CompletableFuture异步模型实践指南 | YONGSSU的技术站点</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f8f7de1ad0ae329b1888cb429395edc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YONGSSU的技术站点</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.suys.top/2018/12/23/2-spring async与CompletableFuture异步模型实践指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongssu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YONGSSU的技术站点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">spring async与CompletableFuture异步模型实践指南</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-23T20:12:07+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://ws1.sinaimg.cn/large/006ZwoZEly1fyotwiwqtkj30dw08vaau.jpg" alt="并发任务头图"></p>
<p>本文主要介绍spring异步请求模型实践使用，spirng中@Async的使用以及java8中提供CompletableFuture常用的API组合，利用这些现成的工具，可以解决平时项目中遇到的并发任务问题。</p>
<h2 id="servlet3-0-async-io"><a href="#servlet3-0-async-io" class="headerlink" title="servlet3.0 async io"></a>servlet3.0 async io</h2><p>有时候，Filter 及/或 Servlet 在生成响应之前必须等待一些资源或事件以便完成请求处理。比如，Servlet 在进行生成一个响应之前可能等待一个可用的 JDBC 连接，或者一个远程 web 服务的响应，或者一个 JMS 消息，或者一个应用程序事件。在 Servlet 中等待是一个低效的操作，因为这是阻塞操作，从而白白占用一个线程或其他一些受限资源。许多线程为了等待一个缓慢的资源比如数据库经常发生阻塞，可能引起线程饥饿，且降低整个 Web 容器的服务质量。当Servlet 3.0 引入了异步处理请求的能力，使线程可以返回到容器，从而执行更多的任务。当开始异步处理请求时，另一个线程或回调可以或者产生响应，或者调用完成（complete）或请求分派（dispatch），这样，它可以在容器上下文使用 AsyncContext.dispatch 方法运行。一个典型的异步处理事件顺序是：</p>
<pre><code>1. 请求被接收到，通过一系列如用于验证的等标准的 filter 之后被传递到 Servlet。
2. servlet 处理请求参数及（或）内容体从而确定请求的类型。
3. 该 servlet 发出请求去获取一些资源或数据，例如，发送一个远程 web 服务请求或加入一个等待 JDBC 连接的队列。
4. servlet 不产生响应并返回。-- 异步重要点
5. 过了一段时间后，所请求的资源变为可用，此时处理线程继续处理事件，要么在同一个线程，要么通过AsyncContext 分派到容器中的一个资源上。
</code></pre><p><a href="http://zhanjindong.com/assets/pdf/Servlet3.1-Specification.pdf" target="_blank" rel="noopener">sevlet3.0协议参考</a></p>
<h2 id="spring-async-requests"><a href="#spring-async-requests" class="headerlink" title="spring async requests"></a>spring async requests</h2><p>Spring MVC对servlet3.0异步请求处理模型进行了扩展</p>
<pre><code>* controller层的DeferredResult and Callable返回值提供了异步返回值的基本支持
* controller可以流式传输多个值，包括SSE和原始数据
* controller可以使用宪英时客户端并对返回响应类型进行响应处理。
</code></pre><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">spring async文档</a></p>
<h3 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a>DeferredResult</h3><p>一旦一个servlet容器异步请求处理为enabled,controller可以封装任何返回值为DeferredResult的方法，参考以下样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/quotes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">quotes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line">    <span class="comment">// 异步设置结果值</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        deferredResult.setResult(getResult());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    log.info(<span class="string">"async string time:&#123;&#125;"</span>, end - start);</span><br><span class="line">    deferredResult.onTimeout(() -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面controller方法可以从不同的线程异步返回结果–比如从外部消息事件，定时任务或者其他任务返回。</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>controller可以支持任何返回值为Callable的方法，参考以下样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/callable"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">processUpload</span><span class="params">(<span class="keyword">final</span> MultipartFile file)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jdk8</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt;  getResult();</span><br><span class="line"><span class="comment">//        return new Callable&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            public String call() throws Exception &#123;</span></span><br><span class="line"><span class="comment">//                return getResult();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以通过配置的TaskExecutor运行给定任务来获取返回值</p>
<h3 id="Servlet异步请求处理的简要概述"><a href="#Servlet异步请求处理的简要概述" class="headerlink" title="Servlet异步请求处理的简要概述"></a>Servlet异步请求处理的简要概述</h3><ul>
<li><p>可以通过调用request.startAsync（）将ServletRequest置于异步模式。这样做的主要作用是Servlet（以及任何过滤器）可以退出，但响应保持打开状态，以便稍后处理完成。</p>
</li>
<li><p>对request.startAsync()的调用返回AsyncContext，可以使用它来进一步控制异步处理。例如，它提供了dispatch方法，类似于Servlet API中的forward，除了这，还允许应用程序在Servlet容器线程上恢复请求处理。</p>
</li>
<li><p>ServletRequest提供对当前DispatcherType的访问，可以使用它来区分处理初始请求，异步调度，转发和其他调度程序类型。</p>
</li>
</ul>
<h3 id="DeferredResult工作流程如下"><a href="#DeferredResult工作流程如下" class="headerlink" title="DeferredResult工作流程如下"></a>DeferredResult工作流程如下</h3><ul>
<li><p>控制器返回DeferredResult并将其保存在可以访问它的某个内存中队列或列表中。</p>
</li>
<li><p>Spring MVC调用request.startAsync().</p>
</li>
<li><p>同时，DispatcherServlet和所有已配置的过滤器退出请求处理线程，但响应仍保持打开状态。</p>
</li>
<li><p>应用程序从某个线程设置DeferredResult，Spring MVC将请求调度回Servlet容器。</p>
</li>
<li><p>再次调用DispatcherServlet，并使用异步生成的返回值继续处理。</p>
</li>
</ul>
<h3 id="Callable处理流程如下"><a href="#Callable处理流程如下" class="headerlink" title="Callable处理流程如下"></a>Callable处理流程如下</h3><ul>
<li><p>controller返回Callable。</p>
</li>
<li><p>Spring MVC调用request.startAsync()并将Callable提交给TaskExecutor以便在单独的线程中进行处理。</p>
</li>
<li><p>同时，DispatcherServlet和所有过滤器退出Servlet容器线程，但响应仍保持打开状态。</p>
</li>
<li><p>最终Callable产生一个结果，Spring MVC将请求发送回Servlet容器以完成处理。</p>
</li>
<li><p>再次调用DispatcherServlet，并使用来自Callable的异步生成的返回值继续处理。</p>
</li>
</ul>
<p><a href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support" target="_blank" rel="noopener">spring3.2异步支持介绍</a></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当用DeferredResult时候，当有异常的时候可以选择setResult或者setErrorResult,在这两种情况下，Spring MVC都会将请求发送回Servlet容器以完成处理。然后将其视为控制器方法返回给定值或者就好像它产生了给定的异常一样。然后异常通过常规异常处理机制（例如，调用@ExceptionHandler方法）。当使用Callable时，会出现类似的处理逻辑，主要区别在于从Callable返回结果，或者由它引发异常。异常处理参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        deferredResult.setErrorResult(<span class="keyword">new</span> RuntimeException(<span class="string">"异常情况容错处理，打印异常信息"</span>).getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    log.info(<span class="string">"async string time:&#123;&#125;"</span>, end - start);</span><br><span class="line">    deferredResult.onTimeout(() -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/timeout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;(<span class="number">3000L</span>);</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        deferredResult.onTimeout(() -&gt; &#123;log.info(<span class="string">"超时任务任务处理"</span>);  deferredResult.setErrorResult(<span class="string">"超时任务容错处理"</span>); &#125;);</span><br><span class="line">        deferredResult.setResult(getResult());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    log.info(<span class="string">"async string time:&#123;&#125;"</span>, end - start);</span><br><span class="line">    deferredResult.onTimeout(() -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种相当于处理了异常，然后给前端返回封装的异常结果.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">customHandler</span><span class="params">(RuntimeException runtimeException)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"相关异常处理"</span>, runtimeException);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种会处理此controller的异常，可以定义自己的业务相关异常，然后在此方法中统一处理异常。</p>
<h3 id="异步拦截器AsyncHandlerInterceptor"><a href="#异步拦截器AsyncHandlerInterceptor" class="headerlink" title="异步拦截器AsyncHandlerInterceptor"></a>异步拦截器AsyncHandlerInterceptor</h3><p>HandlerInterceptor实例可以是AsyncHandlerInterceptor类型，用于接收启动异步处理（而不是postHandle和afterCompletion）的初始请求的afterConcurrentHandlingStarted回调。<br>HandlerInterceptor实现还可以注册CallableProcessingInterceptor或DeferredResultProcessingInterceptor，以更深入地集成异步请求的生命周期（例如，处理超时事件）。<br>DeferredResult提供onTimeout（Runnable）和onCompletion（Runnable）回调。有关更多详细信息，请参阅DeferredResult的javadoc。Callable可以替代WebAsyncTask，它公开了超时和完成回调的其他方法。</p>
<p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">spring-async文档参考</a><br>[spring响应式编程文档][<a href="https://docs.spring.io/spring-framework/docs/5.0.0.M1/spring-framework-reference/html/web-reactive.html]" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/5.0.0.M1/spring-framework-reference/html/web-reactive.html]</a></p>
<h2 id="spring-Async注解"><a href="#spring-Async注解" class="headerlink" title="spring @Async注解"></a>spring @Async注解</h2><h3 id="启用-Async配置"><a href="#启用-Async配置" class="headerlink" title="启用@Async配置"></a>启用@Async配置</h3><p>使用@Async注释bean的方法将使其在单独的线程中执行，即调用者不会等待被调用方法的完成。</p>
<p>启用Java配置的异步处理开始 - 只需将@EnableAsync添加到配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAsyncConfig</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>xml配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"myexecutor"</span> <span class="attr">pool-size</span>=<span class="string">"5"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"myexecutor"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般启用注释就足够了，但正如您所期望的那样，还有一些简单的配置选项：</p>
<ul>
<li>annotation - 默认情况下，@EnableAsync检测Spring的@Async注释和EJB 3.1 javax.ejb.Asynchronous;*此选项也可用于检测其他用户定义的注释类型</li>
<li>mode  - 指示应使用的建议类型 - 基于JDK代理或AspectJ编织</li>
<li>proxyTargetClass  - 表示应该使用的代理类型 -  CGLIB或JDK;仅当模式设置为AdviceMode.PROXY时，此属性才有效</li>
<li>order  - 设置应该应用AsyncAnnotationBeanPostProcessor的顺序;默认情况下，它最后运行，只是为了考虑所有现有的代理</li>
</ul>
<h3 id="Async注解"><a href="#Async注解" class="headerlink" title="@Async注解"></a>@Async注解</h3><p>@Async有两个限制</p>
<ul>
<li>它必须仅适用于public方法</li>
<li>自调用 - 从同一个类中调用异步方法 - 将无法正常工作</li>
</ul>
<p>原因很简单 - 该方法需要公开才能被代理。并且自调用不起作用，因为它绕过代理并直接调用底层方法。</p>
<h3 id="返回样例"><a href="#返回样例" class="headerlink" title="返回样例"></a>返回样例</h3><p>最简单的是返回void</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethodWithVoidReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Execute method asynchronously. "</span></span><br><span class="line">      + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有返回值的返回类型必须用Future包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">asyncMethodWithReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Execute method asynchronously - "</span></span><br><span class="line">      + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;String&gt;(<span class="string">"hello world !!!!"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncAnnotationForMethodsWithReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Invoking an asynchronous method. "</span></span><br><span class="line">      + Thread.currentThread().getName());</span><br><span class="line">    Future&lt;String&gt; future = asyncAnnotationExample.asyncMethodWithReturnType();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Result from asynchronous process - "</span> + future.get());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Continue doing something else. "</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义Executors"><a href="#自定义Executors" class="headerlink" title="自定义Executors"></a>自定义Executors</h3><p>默认情况下，Spring使用SimpleAsyncTaskExecutor实际异步运行这些方法。可以在两个级别覆盖默认值 - 在应用程序级别或单个方法级别。</p>
<p>方法级别:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义异步线程池</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAsyncConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"threadPoolTaskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方法指定线程池</span></span><br><span class="line"><span class="meta">@Async</span>(<span class="string">"threadPoolTaskExecutor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethodWithConfiguredExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Execute method with configured executor - "</span></span><br><span class="line">      + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用级别：<br>配置类应该实现AsyncConfigurer接口 - 这意味着它具有getAsyncExecutor（）方法的实现。在这里，我们将返回整个应用程序的执行程序 - 现在它成为运行使用@Async注释的方法的默认执行程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p>当方法返回类型是Future时，异常处理很容易 -  Future.get（）方法将抛出异常。<br>但是，如果返回类型为void，则异常不会传播到调用线程。因此，我们需要添加额外的配置来处理异常。<br>我们将通过实现AsyncUncaughtExceptionHandler接口来创建自定义异步异常处理程序。当存在任何未捕获的异步异常时，将调用handleUncaughtException（）方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAsyncExceptionHandler</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Throwable throwable, Method method, Object... obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Exception message - "</span> + throwable.getMessage());</span><br><span class="line">        System.out.println(<span class="string">"Method name - "</span> + method.getName());</span><br><span class="line">        <span class="keyword">for</span> (Object param : obj) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Parameter value - "</span> + param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上一节中，我们查看了配置类实现的AsyncConfigurer接口。作为其中的一部分，我们还需要覆盖getAsyncUncaughtExceptionHandler（）方法以返回我们的自定义异步异常处理程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomAsyncExceptionHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baeldung.com/spring-async" target="_blank" rel="noopener">spring-async使用参考</a><br><a href="https://www.baeldung.com/spring-events" target="_blank" rel="noopener">spring event使用</a></p>
<h2 id="java8-CompleteFuture异步任务使用"><a href="#java8-CompleteFuture异步任务使用" class="headerlink" title="java8 CompleteFuture异步任务使用"></a>java8 CompleteFuture异步任务使用</h2><h3 id="java8-CompleteFuture简介"><a href="#java8-CompleteFuture简介" class="headerlink" title="java8 CompleteFuture简介"></a>java8 CompleteFuture简介</h3><p>异步计算很难推理。通常我们希望将任何计算视为一系列步骤。但是在异步计算的情况下，表示为回调的动作往往分散在代码中或者深深地嵌套在彼此内部。当我们需要处理其中一个步骤中可能发生的错误时，情况变得更糟。</p>
<p>Future 5接口在Java 5中添加，作为异步计算的结果，但它没有任何方法来组合这些计算或处理可能的错误。</p>
<p>在Java 8中，引入了CompletableFuture类。与Future接口一起，它还实现了CompletionStage接口。此接口定义了可与其他步骤组合的异步计算步骤的契约。</p>
<p>CompletableFuture同时是一个构建块和一个框架，具有大约50种不同的组合，组合，执行异步计算步骤和处理错误的方法。</p>
<p>如此庞大的API可能会令人难以招架，但这些API大多属于几个明确且不同的用例</p>
<h3 id="CompletableFuture基本使用"><a href="#CompletableFuture基本使用" class="headerlink" title="CompletableFuture基本使用"></a>CompletableFuture基本使用</h3><p>首先，CompletableFuture类实现Future接口，因此您可以将其用作Future实现，但具有额外的完成逻辑。</p>
<p>例如，您可以使用no-arg构造函数创建此类的实例，以表示未来的某些结果，将其交给使用者，并在将来的某个时间使用complete方法完成。消费者可以使用get方法来阻止当前线程，直到提供此结果。</p>
<p>在下面的示例中，我们有一个创建CompletableFuture实例的方法，然后在另一个线程中旋转一些计算并立即返回Future。</p>
<p>计算完成后，该方法通过将结果提供给完整方法来完成Future：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">calculateAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">      = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        completableFuture.complete(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，calculateAsync方法返回Future实例。</p>
<p>我们只是调用方法，接收Future实例并在我们准备阻塞结果时调用它的get方法。</p>
<p>另请注意，get方法抛出一些已检查的异常，即ExecutionException（封装计算期间发生的异常）和InterruptedException（表示执行方法的线程被中断的异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = calculateAsync();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">String result = completableFuture.get();</span><br><span class="line">assertEquals(<span class="string">"Hello"</span>, result);</span><br></pre></td></tr></table></figure>
<p>如果已经知道计算的结果，则可以将static completedFuture方法与表示此计算结果的参数一起使用。然后，Future的get方法永远不会阻塞，而是立即返回此结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = CompletableFuture.completedFuture(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">String result = completableFuture.get();</span><br><span class="line">assertEquals(<span class="string">"Hello"</span>, result);</span><br></pre></td></tr></table></figure>
<p>作为替代方案，您可能希望取消Future的执行。</p>
<p>假设我们没有设法找到结果并决定完全取消异步执行。这可以通过Future的cancel方法完成。此方法接收布尔参数mayInterruptIfRunning，但在CompletableFuture的情况下，它没有任何效果，因为中断不用于控制CompletableFuture的处理。<br>这是异步方法的修改版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">calculateAsyncWithCancellation</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        completableFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用Future.get（）方法阻塞结果时，如果取消将来取消，它将抛出CancellationException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = calculateAsyncWithCancellation();</span><br><span class="line">future.get(); <span class="comment">// CancellationException</span></span><br></pre></td></tr></table></figure>
<h3 id="具有封装计算逻辑的CompletableFuture"><a href="#具有封装计算逻辑的CompletableFuture" class="headerlink" title="具有封装计算逻辑的CompletableFuture"></a>具有封装计算逻辑的CompletableFuture</h3><p>上面的代码允许我们选择任何并发执行机制，但是如果我们想跳过这个样板并简单地异步执行一些代码呢？<br>静态方法runAsync和supplyAsync允许我们相应地从Runnable和Supplier功能类型中创建CompletableFuture实例。<br>Runnable和Supplier都是功能接口，由于新的Java 8功能，它们允许将它们的实例作为lambda表达式传递。Runnable接口与线程中使用的旧接口相同，不允许返回值。<br>Supplier接口是一个通用的功能接口，只有一个没有参数的方法，并返回一个参数化类型的值。这允许将Supplier的实例作为lambda表达式提供，该表达式执行计算并返回结果。这很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future  = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">assertEquals(<span class="string">"Hello"</span>, future.get());</span><br></pre></td></tr></table></figure>
<h3 id="处理异步计算的结果"><a href="#处理异步计算的结果" class="headerlink" title="处理异步计算的结果"></a>处理异步计算的结果</h3><p>处理计算结果的最通用方法是将其提供给函数。 thenApply方法就是这样做的：接受一个Function实例，用它来处理结果并返回一个包含函数返回值的Future：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture.thenApply(s -&gt; s + <span class="string">" World"</span>);</span><br><span class="line">assertEquals(<span class="string">"Hello World"</span>, future.get());</span><br></pre></td></tr></table></figure>
<p>如果不需要在Future链中返回值，则可以使用Consumer功能接口的实例。它的单个方法接受一个参数并返回void。<br>在CompletableFuture中有一个用于此用例的方法 -  thenAccept方法接收Consumer并将计算结果传递给它。最后的future.get（）调用返回Void类型的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture.thenAccept(s -&gt; System.out.println(<span class="string">"Computation returned: "</span> + s));</span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>
<p>最后，如果您既不需要计算的值也不想在链的末尾返回一些值，那么您可以将Runnable lambda传递给thenRun方法。在以下示例中，在调用future.get（）方法之后，我们只需在控制台中打印一行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture.thenRun(() -&gt; System.out.println(<span class="string">"Computation finished."</span>));</span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>
<h3 id="组合Future"><a href="#组合Future" class="headerlink" title="组合Future"></a>组合Future</h3><p>CompletableFuture API的最佳部分是能够在一系列计算步骤中组合CompletableFuture实例。<br>这种链接的结果本身就是CompletableFuture，允许进一步链接和组合。这种方法在函数式语言中无处不在，通常被称为monadic设计模式。<br>在下面的示例中，我们使用thenCompose方法按顺序链接两个Futures。<br>请注意，此方法采用一个返回CompletableFuture实例的函数。该函数的参数是先前计算步骤的结果。这允许我们在下一个CompletableFuture的lambda中使用这个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>)</span><br><span class="line">    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">" World"</span>));</span><br><span class="line">assertEquals(<span class="string">"Hello World"</span>, completableFuture.get());</span><br></pre></td></tr></table></figure>
<p>thenCompose方法与thenApply一起实现monadic模式的基本构建块。它们与Java 8中提供的Stream和Optional类的map和flatMap方法密切相关。<br>两种方法都接收一个函数并将其应用于计算结果，但thenCompose（flatMap）方法接收一个返回另一个相同类型对象的函数。此功能结构允许将这些类的实例组合为构建块。<br>如果要执行两个独立的Futures并对其结果执行某些操作，请使用接受Future的thenCombine方法和具有两个参数的Function来处理两个结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>)</span><br><span class="line">    .thenCombine(CompletableFuture.supplyAsync(() -&gt; <span class="string">" World"</span>), (s1, s2) -&gt; s1 + s2));</span><br><span class="line">assertEquals(<span class="string">"Hello World"</span>, completableFuture.get());</span><br></pre></td></tr></table></figure>
<p>更简单的情况是，当您想要使用两个Futures的结果时，但不需要将任何结果值传递给Future链。thenAcceptBoth方法可以帮助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>)</span><br><span class="line">  .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; <span class="string">" World"</span>), (s1, s2) -&gt; System.out.println(s1 + s2));</span><br></pre></td></tr></table></figure>
<h3 id="thenApply（）和thenCompose（）之间的区别"><a href="#thenApply（）和thenCompose（）之间的区别" class="headerlink" title="thenApply（）和thenCompose（）之间的区别"></a>thenApply（）和thenCompose（）之间的区别</h3><p>在前面的部分中，我们展示了关于thenApply（）和thenCompose（）的示例。这两个API都有助于链接不同的CompletableFuture调用，但这两个函数的使用是不同的。</p>
<p>thenApply()<br>此方法用于处理先前调用的结果。但是，要记住的一个关键点是返回类型将合并所有调用。因此，当我们想要转换CompletableFuture调用的结果时，此方法很有用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; finalResult = compute().thenApply(s-&gt; s + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>thenCompose()<br>thenCompose（）方法类似于thenApply（），因为它们都返回一个新的Completion Stage。但是，thenCompose（）使用前一个阶段作为参数。它会直接使结果变平并返回Future，而不是我们在thenApply（）中观察到的嵌套Future:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;Integer&gt; <span class="title">computeAnother</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">CompletableFuture&lt;Integer&gt; finalResult = compute().thenCompose(<span class="keyword">this</span>::computeAnother);</span><br></pre></td></tr></table></figure>
<p>因此，如果想要链接CompletableFuture方法，那么最好使用thenCompose（）。另请注意，这两种方法之间的区别类似于map（）和flatMap（）之间的区别。</p>
<h3 id="并行运行多个Future"><a href="#并行运行多个Future" class="headerlink" title="并行运行多个Future"></a>并行运行多个Future</h3><p>当我们需要并行执行多个Futures时，我们通常希望等待所有Futures执行然后处理它们的组合结果。CompletableFuture.allOf静态方法允许等待作为var-arg提供的所有Futures的完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Beautiful"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"World"</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">combinedFuture.get();</span><br><span class="line">assertTrue(future1.isDone());</span><br><span class="line">assertTrue(future2.isDone());</span><br><span class="line">assertTrue(future3.isDone());</span><br></pre></td></tr></table></figure>
<p>请注意，CompletableFuture.allOf（）的返回类型是CompletableFuture <void>。这种方法的局限在于它不会返回所有Future的综合结果。相反，您必须手动从Futures获取结果。幸运的是，CompletableFuture.join（）方法和Java 8 Streams API使它变得简单：</void></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String combined = Stream.of(future1, future2, future3)</span><br><span class="line">  .map(CompletableFuture::join).collect(Collectors.joining(<span class="string">" "</span>));</span><br><span class="line">assertEquals(<span class="string">"Hello Beautiful World"</span>, combined);</span><br></pre></td></tr></table></figure>
<p>CompletableFuture.join（）方法与get方法类似，但是如果Future未正常完成，它会抛出未经检查的异常。<br>这使得它可以在Stream.map（）方法中用作方法引用。</p>
<h3 id="error处理"><a href="#error处理" class="headerlink" title="error处理"></a>error处理</h3><p>对于异步计算步骤链中的错误处理，必须以类似的方式调整throw / catch惯用法。</p>
<p>CompletableFuture类允许您在特殊的句柄方法中处理它，而不是在语法块中捕获异常。此方法接收两个参数：计算结果（如果成功完成）和抛出异常（如果某些计算步骤未正常完成）。</p>
<p>在下面的示例中，我们使用handle方法在问候语的异步计算完成时出现错误，因为没有提供namme：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class="line">  =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Computation error!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">  &#125;)&#125;).handle((s, t) -&gt; s != <span class="keyword">null</span> ? s : <span class="string">"Hello, Stranger!"</span>);</span><br><span class="line">assertEquals(<span class="string">"Hello, Stranger!"</span>, completableFuture.get());</span><br></pre></td></tr></table></figure>
<p>作为替代方案，假设我们想要使用值手动完成Future，如第一个示例中所示，但也可以使用异常来完成它。completeExceptionally方法适用于此。<br>以下示例中的completableFuture.get（）方法抛出ExecutionException，并将RuntimeException作为其原因：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">completableFuture.completeExceptionally(<span class="keyword">new</span> RuntimeException(<span class="string">"Calculation failed!"</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">completableFuture.get(); <span class="comment">// ExecutionException</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们可以使用handle方法异步处理异常，但是使用get方法，我们可以使用更典型的同步异常处理方法。</p>
<h3 id="Async方法"><a href="#Async方法" class="headerlink" title="Async方法"></a>Async方法</h3><p>CompletableFuture类中的流体API的大多数方法都有两个带有Async后缀的附加变体。这些方法通常用于在另一个线程中运行相应的执行步骤。<br>没有Async postfix的方法使用调用线程运行下一个执行阶段。不带Executor参数的Async方法使用使用ForkJoinPool.commonPool（）方法访问的Executor的公共fork / join池实现来运行一个步骤。带有Executor参数的Async方法使用传递的Executor运行一个步骤。<br>这是一个使用Function实例处理计算结果的修改示例。<br>唯一可见的区别是thenApplyAsync方法。但在幕后，函数的应用程序被包装到ForkJoinTask实例中，这样可以进一步并行化您的计算并更多地使用系统资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture  = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture.thenApplyAsync(s -&gt; s + <span class="string">" World"</span>);</span><br><span class="line">assertEquals(<span class="string">"Hello World"</span>, future.get());</span><br></pre></td></tr></table></figure>
<h3 id="java9-增强API简介"><a href="#java9-增强API简介" class="headerlink" title="java9 增强API简介"></a>java9 增强API简介</h3><p>java9 CompleteFuture被进一步增强</p>
<ul>
<li>New factory methods added</li>
<li>Support for delays and timeouts</li>
<li>mproved support for subclassing.</li>
</ul>
<p>引入了新的api:</p>
<ul>
<li>Executor defaultExecutor()</li>
<li>CompletableFuture<u> newIncompleteFuture()</u></li>
<li>CompletableFuture<t> copy()</t></li>
<li>CompletionStage<t> minimalCompletionStage()</t></li>
<li>CompletableFuture<t> completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)</t></li>
<li>CompletableFuture<t> completeAsync(Supplier&lt;? extends T&gt; supplier)</t></li>
<li>CompletableFuture<t> orTimeout(long timeout, TimeUnit unit)</t></li>
<li>CompletableFuture<t> completeOnTimeout(T value, long timeout, TimeUnit unit)</t></li>
</ul>
<p>新增了一些方法：</p>
<ul>
<li>Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)</li>
<li>Executor delayedExecutor(long delay, TimeUnit unit)</li>
<li><u> CompletionStage<u> completedStage(U value)</u></u></li>
<li><u> CompletionStage<u> failedStage(Throwable ex)</u></u></li>
<li>( <u> CompletableFuture<u> failedFuture(Throwable ex)</u></u></li>
</ul>
<p>最后，为了解决超时问题，Java 9引入了另外两个新功能：</p>
<ul>
<li>orTimeout()</li>
<li>completeOnTimeout()</li>
</ul>
<h4 id="并发任务获取结果并返回组合结果样例"><a href="#并发任务获取结果并返回组合结果样例" class="headerlink" title="并发任务获取结果并返回组合结果样例"></a>并发任务获取结果并返回组合结果样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * CompleteFuture模拟并发任务，并组合结果，注意其中任务异常的处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = asyncTask();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">asyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    params.add(<span class="string">"task1"</span>);</span><br><span class="line">    params.add(<span class="string">"task2"</span>);</span><br><span class="line">    params.add(<span class="string">"task3"</span>);</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; futures = params.stream().map(t -&gt; CompletableFuture.supplyAsync(() -&gt;task(t)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 任务触发与结果获取分开，使得获取结果不阻塞任务的执行</span></span><br><span class="line">    <span class="keyword">return</span> futures.stream().map(t -&gt; t.handle((s, e) -&gt; e != <span class="keyword">null</span> ? <span class="string">"default value"</span> : s))</span><br><span class="line">            .map(t -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> t.get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"default value2"</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">task</span><span class="params">(String no)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + no;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baeldung.com/java-completablefuture" target="_blank" rel="noopener">CompleteFuture使用介绍参考</a></p>
<p><a href="https://github.com/yongssu/demo/tree/master/spring-boot-async" target="_blank" rel="noopener">本文相关测试代码参考</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/servlet/" rel="tag"># servlet</a>
          
            <a href="/tags/spring/" rel="tag"># spring</a>
          
            <a href="/tags/async/" rel="tag"># async</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/18/1-利用hexo和github建立个人技术博客站点/" rel="next" title="利用hexo和github建立个人技术博客站点">
                <i class="fa fa-chevron-left"></i> 利用hexo和github建立个人技术博客站点
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/08/3-redis单点与集群安装实践/" rel="prev" title="redis单点与集群安装实践">
                redis单点与集群安装实践 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yongssu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yongssu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yongssu@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#servlet3-0-async-io"><span class="nav-number">1.</span> <span class="nav-text">servlet3.0 async io</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-async-requests"><span class="nav-number">2.</span> <span class="nav-text">spring async requests</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DeferredResult"><span class="nav-number">2.1.</span> <span class="nav-text">DeferredResult</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable"><span class="nav-number">2.2.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet异步请求处理的简要概述"><span class="nav-number">2.3.</span> <span class="nav-text">Servlet异步请求处理的简要概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeferredResult工作流程如下"><span class="nav-number">2.4.</span> <span class="nav-text">DeferredResult工作流程如下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable处理流程如下"><span class="nav-number">2.5.</span> <span class="nav-text">Callable处理流程如下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理"><span class="nav-number">2.6.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步拦截器AsyncHandlerInterceptor"><span class="nav-number">2.7.</span> <span class="nav-text">异步拦截器AsyncHandlerInterceptor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-Async注解"><span class="nav-number">3.</span> <span class="nav-text">spring @Async注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启用-Async配置"><span class="nav-number">3.1.</span> <span class="nav-text">启用@Async配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Async注解"><span class="nav-number">3.2.</span> <span class="nav-text">@Async注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回样例"><span class="nav-number">3.3.</span> <span class="nav-text">返回样例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义Executors"><span class="nav-number">3.4.</span> <span class="nav-text">自定义Executors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理-1"><span class="nav-number">3.5.</span> <span class="nav-text">异常处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java8-CompleteFuture异步任务使用"><span class="nav-number">4.</span> <span class="nav-text">java8 CompleteFuture异步任务使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java8-CompleteFuture简介"><span class="nav-number">4.1.</span> <span class="nav-text">java8 CompleteFuture简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture基本使用"><span class="nav-number">4.2.</span> <span class="nav-text">CompletableFuture基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具有封装计算逻辑的CompletableFuture"><span class="nav-number">4.3.</span> <span class="nav-text">具有封装计算逻辑的CompletableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理异步计算的结果"><span class="nav-number">4.4.</span> <span class="nav-text">处理异步计算的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合Future"><span class="nav-number">4.5.</span> <span class="nav-text">组合Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thenApply（）和thenCompose（）之间的区别"><span class="nav-number">4.6.</span> <span class="nav-text">thenApply（）和thenCompose（）之间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行运行多个Future"><span class="nav-number">4.7.</span> <span class="nav-text">并行运行多个Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#error处理"><span class="nav-number">4.8.</span> <span class="nav-text">error处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Async方法"><span class="nav-number">4.9.</span> <span class="nav-text">Async方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java9-增强API简介"><span class="nav-number">4.10.</span> <span class="nav-text">java9 增强API简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并发任务获取结果并返回组合结果样例"><span class="nav-number">4.10.1.</span> <span class="nav-text">并发任务获取结果并返回组合结果样例</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yongssu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
